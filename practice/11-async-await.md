# Python Async/Await 学习指南

## 要点总结

1. **异步编程基础**：
   - 异步编程是一种允许程序在等待某些操作完成时继续执行其他任务的编程范式
   - Python 3.5+ 引入了 `async/await` 语法，使异步编程更加直观

2. **核心概念**：
   - `async def`：定义协程函数
   - `await`：暂停协程执行，等待另一个协程完成
   - 协程(Coroutine)：可以暂停和恢复的特殊函数
   - 事件循环(Event Loop)：协调和调度协程执行的机制
   - 任务(Task)：协程的包装器，使协程能在事件循环中调度

3. **asyncio 库**：
   - Python 标准库，提供异步编程的基础设施
   - 包含事件循环、协程、任务、Future 等工具

4. **理解要点**：
   - 异步代码不等于多线程，它是在单线程中实现并发
   - 异步操作主要用于 I/O 密集型任务，如网络请求、文件操作
   - 在 CPU 密集型任务中，异步编程优势不明显

5. **最佳实践**：
   - 不要在异步函数中使用阻塞操作
   - 使用 `asyncio.gather()` 并发运行多个协程
   - 使用 `asyncio.create_task()` 创建任务

## 理解方法

1. **思维转变**：
   - 从顺序执行思维转变为事件驱动思维
   - 理解"非阻塞"的概念：代码可以在等待某些操作时继续执行其他任务

2. **实践学习**：
   - 从简单的例子开始，如异步睡眠函数
   - 逐步尝试更复杂的应用，如异步网络请求、文件操作

3. **可视化理解**：
   - 将协程想象为可以在特定点暂停和恢复的函数
   - 将事件循环想象为一个调度器，它决定哪个协程何时运行

4. **对比学习**：
   - 对比同步和异步代码的差异
   - 理解何时使用异步编程更有优势

## 练习题

### 1. 创建第一个协程

**题目**：创建一个简单的协程函数 `hello()`，它打印 "Hello"，等待 1 秒，然后打印 "World"。

**解题思路**：
- 使用 `async def` 定义协程函数
- 使用 `asyncio.sleep()` 作为异步等待操作
- 使用 `asyncio.run()` 运行协程

**验收标准**：
- 正确使用 `async def` 定义协程
- 正确使用 `await asyncio.sleep(1)` 进行异步等待
- 程序输出 "Hello"，等待约 1 秒后，输出 "World"
- 使用 `asyncio.run()` 运行协程

### 2. 并发执行多个协程

**题目**：创建三个协程函数，分别打印不同的消息并等待不同的时间。然后并发执行这三个协程，观察输出顺序。

**解题思路**：
- 创建三个不同的协程函数
- 使用 `asyncio.gather()` 并发执行它们
- 观察输出顺序与等待时间的关系

**验收标准**：
- 创建三个协程函数，每个函数等待不同的时间（如 1秒、2秒、3秒）
- 使用 `asyncio.gather()` 并发执行这些协程
- 程序总执行时间应接近最长的单个等待时间，而不是三个等待时间的总和
- 输出顺序应该按照等待时间的长短排序

### 3. 实现异步计数器

**题目**：创建一个异步计数器函数，它接受一个名称和计数上限，每秒递增计数并打印，直到达到上限。

**解题思路**：
- 使用 `async def` 定义计数器函数
- 使用循环和 `asyncio.sleep()` 实现每秒递增
- 打印当前计数值和计数器名称

**验收标准**：
- 函数接受名称和上限两个参数
- 每秒打印一次当前计数和名称
- 当计数达到上限时停止
- 能够并发运行多个计数器实例

### 4. 异步文件读取

**题目**：编写一个异步函数，从指定的文本文件中读取内容并返回。使用 `aiofiles` 库。

**解题思路**：
- 安装 `aiofiles` 库：`pip install aiofiles`
- 创建异步函数使用 `async with aiofiles.open()` 打开文件
- 使用 `await file.read()` 读取内容

**验收标准**：
- 正确安装和导入 `aiofiles` 库
- 使用异步上下文管理器打开文件
- 异步读取文件内容
- 函数返回文件的完整内容
- 处理文件不存在的异常情况

### 5. 实现异步 HTTP 请求

**题目**：使用 `aiohttp` 库编写一个异步函数，获取指定 URL 的内容并返回。

**解题思路**：
- 安装 `aiohttp` 库：`pip install aiohttp`
- 创建异步函数使用 `async with aiohttp.ClientSession()` 创建会话
- 使用 `await session.get(url)` 发送请求
- 使用 `await response.text()` 获取响应内容

**验收标准**：
- 正确安装和导入 `aiohttp` 库
- 使用异步上下文管理器创建会话和发送请求
- 异步获取响应内容
- 函数返回网页的文本内容
- 处理请求失败的异常情况

### 6. 实现并发 HTTP 请求

**题目**：编写一个函数，并发获取多个 URL 的内容，并返回一个字典，键为 URL，值为对应的内容。

**解题思路**：
- 使用 `aiohttp` 库
- 创建一个异步函数处理单个 URL
- 使用 `asyncio.gather()` 并发执行多个请求
- 将结果组织成字典返回

**验收标准**：
- 函数接受一个 URL 列表作为参数
- 正确并发发送所有请求
- 返回一个字典，包含所有 URL 和对应的内容
- 处理任何请求可能失败的情况
- 程序执行时间应该接近单个请求的时间，而不是所有请求时间的总和

### 7. 实现异步超时控制

**题目**：编写一个异步函数，它尝试获取一个 URL 的内容，但如果请求超过 5 秒未完成，则抛出超时异常。

**解题思路**：
- 使用 `asyncio.wait_for()` 函数设置超时
- 创建获取 URL 内容的异步函数
- 捕获并处理 `asyncio.TimeoutError` 异常

**验收标准**：
- 正确使用 `asyncio.wait_for()` 设置超时
- 当请求在 5 秒内完成时，返回内容
- 当请求超过 5 秒未完成时，捕获超时异常并返回适当的错误信息
- 函数应该优雅地处理超时情况，不应崩溃

### 8. 实现异步生成器

**题目**：创建一个异步生成器函数，它每隔 1 秒产生一个递增的数字，总共产生 5 个数字。

**解题思路**：
- 使用 `async def` 和 `yield` 创建异步生成器
- 使用 `asyncio.sleep()` 实现间隔
- 使用循环生成递增数字

**验收标准**：
- 正确定义异步生成器函数
- 函数每隔约 1 秒产生一个数字
- 总共产生 5 个递增的数字（如 1, 2, 3, 4, 5）
- 使用 `async for` 循环消费生成器

### 9. 实现异步上下文管理器

**题目**：创建一个异步上下文管理器类，它在进入时打印 "Starting"，退出时打印 "Ending"，并在其中等待 2 秒。

**解题思路**：
- 创建一个类，实现 `__aenter__` 和 `__aexit__` 异步方法
- 在 `__aenter__` 中打印开始信息
- 在 `__aexit__` 中打印结束信息
- 使用 `asyncio.sleep()` 实现等待

**验收标准**：
- 正确实现 `__aenter__` 和 `__aexit__` 异步方法
- 进入上下文时打印 "Starting"
- 退出上下文时打印 "Ending"
- 在上下文中等待约 2 秒
- 可以使用 `async with` 语句使用该上下文管理器

### 10. 异步迭代器

**题目**：创建一个异步迭代器类，它可以异步迭代一个列表，每次迭代等待 0.5 秒。

**解题思路**：
- 创建一个类，实现 `__aiter__` 和 `__anext__` 异步方法
- 在初始化时接收一个列表
- 在 `__anext__` 中返回下一个元素，如果没有更多元素则抛出 `StopAsyncIteration`
- 使用 `asyncio.sleep()` 实现等待

**验收标准**：
- 正确实现 `__aiter__` 和 `__anext__` 异步方法
- 类初始化时接收一个列表参数
- 每次迭代等待约 0.5 秒
- 迭代完成所有元素后抛出 `StopAsyncIteration`
- 可以使用 `async for` 循环遍历该迭代器

### 11. 实现异步回调

**题目**：创建一个异步函数，它执行一个操作，然后调用一个回调函数通知操作完成。回调函数也应该是异步的。

**解题思路**：
- 创建一个主异步函数，接受一个异步回调函数作为参数
- 在主函数中执行某些操作（如等待一段时间）
- 操作完成后，使用 `await` 调用回调函数

**验收标准**：
- 主函数接受一个异步回调函数作为参数
- 主函数执行某些异步操作
- 操作完成后，使用 `await` 调用回调函数
- 回调函数能够接收并处理主函数传递的结果
- 整个流程应该是异步的

### 12. 异步队列处理

**题目**：使用 `asyncio.Queue` 实现一个生产者-消费者模式，其中一个生产者每秒产生一个随机数并放入队列，三个消费者从队列中取出数字并处理。

**解题思路**：
- 创建 `asyncio.Queue` 实例
- 实现生产者协程，生成随机数并放入队列
- 实现消费者协程，从队列中取出数字并处理
- 使用 `asyncio.gather()` 并发运行生产者和多个消费者

**验收标准**：
- 正确创建和使用 `asyncio.Queue`
- 生产者每秒生成一个随机数并放入队列
- 三个消费者并发从队列中取出数字并处理
- 每个消费者打印自己的标识和处理的数字
- 程序应该能够正确协调生产者和消费者之间的通信

### 13. 异步锁的使用

**题目**：创建一个共享资源（如计数器）和多个协程，使用 `asyncio.Lock` 确保对共享资源的访问是互斥的。

**解题思路**：
- 创建一个共享计数器变量
- 创建 `asyncio.Lock` 实例
- 实现多个协程，它们尝试增加计数器
- 使用 `async with lock:` 保护对计数器的访问

**验收标准**：
- 正确创建和使用 `asyncio.Lock`
- 多个协程尝试增加同一个计数器
- 使用锁保护对计数器的访问，确保操作是互斥的
- 每个协程在获取锁前后打印消息，以验证互斥性
- 程序最终输出正确的计数器值

### 14. 异步事件的使用

**题目**：使用 `asyncio.Event` 实现一个简单的信号系统，其中一个协程等待信号，另一个协程在 3 秒后发送信号。

**解题思路**：
- 创建 `asyncio.Event` 实例
- 实现等待协程，它等待事件被设置
- 实现信号协程，它在延迟后设置事件
- 使用 `asyncio.gather()` 并发运行两个协程

**验收标准**：
- 正确创建和使用 `asyncio.Event`
- 等待协程调用 `await event.wait()` 等待信号
- 信号协程在等待约 3 秒后调用 `event.set()`
- 等待协程在收到信号后继续执行并打印消息
- 程序应该演示事件如何用于协程间的同步

### 15. 实现异步任务取消

**题目**：创建一个长时间运行的协程任务，然后在 2 秒后取消它，正确处理取消异常。

**解题思路**：
- 创建一个长时间运行的协程（如循环 10 秒）
- 使用 `asyncio.create_task()` 创建任务
- 使用 `asyncio.sleep()` 等待 2 秒
- 调用 `task.cancel()` 取消任务
- 使用 try/except 捕获 `asyncio.CancelledError`

**验收标准**：
- 正确创建长时间运行的协程和任务
- 在 2 秒后调用 `task.cancel()` 取消任务
- 在协程中正确捕获和处理 `asyncio.CancelledError`
- 打印适当的消息指示任务已被取消
- 程序应该优雅地处理任务取消，不应崩溃

### 16. 实现异步超时重试

**题目**：创建一个异步函数，它尝试执行一个可能失败的操作，如果失败或超时，最多重试 3 次。

**解题思路**：
- 创建一个模拟可能失败的异步操作（如随机抛出异常）
- 实现重试逻辑，使用循环和计数器
- 使用 `asyncio.wait_for()` 设置超时
- 捕获异常和超时，决定是否重试

**验收标准**：
- 函数应该尝试执行操作，最多重试 3 次
- 每次尝试都有超时限制（如 2 秒）
- 如果操作成功，返回结果并停止重试
- 如果所有重试都失败，抛出或返回适当的错误
- 每次重试前打印尝试次数和错误信息

### 17. 异步上下文变量

**题目**：使用 `contextvars` 模块在异步任务之间共享上下文变量，演示如何在不同的协程中访问和修改这些变量。

**解题思路**：
- 导入 `contextvars` 模块
- 创建上下文变量：`var = contextvars.ContextVar('var', default='default')`
- 实现多个协程，它们读取和修改上下文变量
- 演示上下文变量如何在协程之间隔离

**验收标准**：
- 正确创建上下文变量
- 实现至少两个协程，它们尝试读取和修改上下文变量
- 演示一个协程中的修改不会影响另一个协程
- 使用 `var.get()` 获取值，`var.set()` 设置值
- 打印适当的消息展示上下文变量的行为

### 18. 异步流控制

**题目**：实现一个异步限流器，它限制并发执行的协程数量不超过 3 个。

**解题思路**：
- 使用 `asyncio.Semaphore` 限制并发数
- 创建一个包装函数，它使用信号量控制访问
- 实现多个协程尝试并发执行
- 使用 `async with semaphore:` 保护协程执行

**验收标准**：
- 正确创建和使用 `asyncio.Semaphore(3)`
- 创建至少 6 个尝试并发执行的协程
- 使用信号量确保任何时候最多只有 3 个协程在执行
- 每个协程在执行前后打印消息，以验证限流效果
- 程序应该清晰地展示限流器的工作原理

### 19. 异步流水线处理

**题目**：实现一个异步数据处理流水线，包含三个阶段：生成数据、处理数据和保存结果，使用队列连接各个阶段。

**解题思路**：
- 创建两个 `asyncio.Queue` 实例连接三个阶段
- 实现生成器协程，生成数据并放入第一个队列
- 实现处理器协程，从第一个队列取数据，处理后放入第二个队列
- 实现保存器协程，从第二个队列取数据并"保存"（打印）
- 使用 `asyncio.gather()` 并发运行三个阶段

**验收标准**：
- 正确创建和使用两个队列连接三个阶段
- 生成器生成一系列数据（如数字 1-10）
- 处理器对数据进行某种转换（如平方）
- 保存器将处理后的数据打印出来
- 整个流水线应该正确协调各个阶段的工作

### 20. 异步与同步代码集成

**题目**：编写一个程序，它在异步环境中调用一个阻塞的同步函数，使用 `asyncio.to_thread()` 避免阻塞事件循环。

**解题思路**：
- 创建一个模拟耗时的同步函数（如使用 `time.sleep()`）
- 创建一个异步主函数
- 使用 `asyncio.to_thread()` 在线程中运行同步函数
- 同时运行其他异步任务，证明事件循环未被阻塞

**验收标准**：
- 正确创建同步函数和异步主函数
- 使用 `asyncio.to_thread()` 在线程中运行同步函数
- 同时运行其他异步任务（如定期打印消息）
- 证明同步函数的执行不会阻塞其他异步任务
- 程序应该清晰地展示如何在异步代码中安全地调用同步函数
